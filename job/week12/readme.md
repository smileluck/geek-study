[toc]

---

# 题目

**1.（必做）**配置 redis 的主从复制，sentinel 高可用，Cluster 集群。

**2.（选做）**练习示例代码里下列类中的作业题:
08cache/redis/src/main/java/io/kimmking/cache/RedisApplication.java

**3.（选做☆）**练习 redission 的各种功能。

**4.（选做☆☆）**练习 hazelcast 的各种功能。

**5.（选做☆☆☆）**搭建 hazelcast 3 节点集群，写入 100 万数据到一个 map，模拟和演 示高可用。

**6.（必做）**搭建 ActiveMQ 服务，基于 JMS，写代码分别实现对于 queue 和 topic 的消息生产和消费，代码提交到 github。

**7.（选做）**基于数据库的订单表，模拟消息队列处理订单：

- 一个程序往表里写新订单，标记状态为未处理 (status=0);
- 另一个程序每隔 100ms 定时从表里读取所有 status=0 的订单，打印一下订单数据，然后改成完成 status=1；
- （挑战☆）考虑失败重试策略，考虑多个消费程序如何协作。

**8.（选做）**将上述订单处理场景，改成使用 ActiveMQ 发送消息处理模式。

**9.（选做）**使用 java 代码，创建一个 ActiveMQ Broker Server，并测试它。

**10.（挑战☆☆）**搭建 ActiveMQ 的 network 集群和 master-slave 主从结构。

**11.（挑战☆☆☆）**基于 ActiveMQ 的 MQTT 实现简单的聊天功能或者 Android 消息推送。

**12.（挑战☆）**创建一个 RabbitMQ，用 Java 代码实现简单的 AMQP 协议操作。

**13.（挑战☆☆）**搭建 RabbitMQ 集群，重新实现前面的订单处理。

**14.（挑战☆☆☆）**使用 Apache Camel 打通上述 ActiveMQ 集群和 RabbitMQ 集群，实现所有写入到 ActiveMQ 上的一个队列 q24 的消息，自动转发到 RabbitMQ。

**15.（挑战☆☆☆）**压测 ActiveMQ 和 RabbitMQ 的性能。





# 作业1 

## redis主从

### 配置文件

我这里使用了redis-window版本自带的conf文件，并修改了两处地方。

文件地址：[redis.windows6379.conf]()

```
# 端口
port 6379

# 目录地址，需要在redis软件目录下，新建6379文件夹
dir ./6379/
```

文件地址：[redis.windows6380.conf]()

```
# 端口
port 6380

# 目录地址，需要在redis软件目录下，新建6379文件夹
dir ./6380/
```



### 启动服务

分别启动我们的6379和6380两个服务

```
redis-server ./redis.windows6379.conf
redis-server ./redis.windows6380.conf
```

### 测试单独服务

1. 连接redis6379服务里执行set、get 和 info。可以看到当前服务是master

```shell
# 连接6379 redis 
redis-cli -p 6379

# set key
set temp6379 6379

get temp6379
# 输出6379

info
# Replication
# role:master
# connected_slaves:0
```

2. 连接redis6380服务里执行set、get 和 info。可以看到当前服务是master

```shell
# 连接6380 redis 
redis-cli -p 6380

# set key
set temp6380 6380

get temp6380
# 输出6380

info
# Replication
# role:master
# connected_slaves:0
```

可以看到目前两个redis服务是独立的两个服务



### 配置6380为6379子机

1. 进入redis6380服务，执行以下命令：

```shell
slaveof 127.0.0.1 6379
```

2. 执行以下 	指令查看当前6380状态

```shell
keys * 
# 输出temp6379，原先的temp6380没有了

get temp6379 
# 输出6379

set temp6380
# 输出(error) READONLY You can't write against a read only replica.
# 从机已经是只读的了，不允许写入数据。

info
# role:slave
# master_host:127.0.0.1
# master_port:6379
# 当前服务已经变成从机了，主机地址是：127.0.0.1:6379
```



### 测试主从

1. 进入redis6379服务，执行以下命令：

```shell
set temp_version 123

info
# role:master
# connected_slaves:1
# slave0:ip=127.0.0.1,port=6380,state=online,offset=484,lag=0
# 当前服务是主机，有一个从机设备，地址是：127.0.0.1:6380
```

2. 进入redis6380服务，执行以下命令：

```shell
keys *
# 输出temp6379和temp_version

get temp_version
# 输出123
```





## sentinel

### 配置文件

配置2个sentinel服务，分别占用26379和26380端口，redis主服务为127.0.0.1 6379，掉线检测为10s

文件地址：[sentinel0.conf]()

```
sentinel myid 8d992c54df8f8677b0b345825f61fb733c73d14c
sentinel deny-scripts-reconfig yes
sentinel monitor mymaster 127.0.0.1 6379 2
sentinel down-after-milliseconds mymaster 10000
# Generated by CONFIG REWRITE
protected-mode no
port 26379
user default on nopass sanitize-payload ~* &* +@all
dir "E:/ZHQ/project/0626/geek-study2/geek-study/job/week12"
```

文件地址：[sentinel1.conf]()

```
sentinel myid 8d992c54df8f8677b0b345825f61fb733c73d14d
sentinel deny-scripts-reconfig yes
sentinel monitor mymaster 127.0.0.1 6379 2
port 26380
sentinel down-after-milliseconds mymaster 10000
# Generated by CONFIG REWRITE
protected-mode no
# user default on nopass sanitize-payload ~* &* +@all
dir "E:/ZHQ/project/0626/geek-study2/geek-study/job/week12"
```

###  启动服务

启动sentinel0 和 sentinel1

```
.\redis-server E:\ZHQ\project\0626\geek-study2\geek-study\job\week12\sentinel0.conf --sentinel

.\redis-server E:\ZHQ\project\0626\geek-study2\geek-study\job\week12\sentinel1.conf --sentinel
```

### 查看服务

将sentinel当做redis连接，执行以下代码查看信息

```shell
redis-cli -p 26379

info 

# Sentinel
sentinel_masters:1
sentinel_tilt:0
sentinel_running_scripts:0
sentinel_scripts_queue_length:0
sentinel_simulate_failure_flags:0
master0:name=mymaster,status=ok,address=127.0.0.1:6379,slaves=1,sentinels=2

# 可以看到当前主机，sentinel服务2个
```



## cluster

### 配置文件



在之前的redis6379基础上修改以下几行代码

文件地址：[cluster.windows7000.conf]()

```
# 端口
port 7000

# 目录地址，需要在redis软件目录下，新建7000文件夹
dir ./7000/

# 开启cluster模式
cluster-enabled yes

# 指定配置文件
cluster-config-file nodes-7000.conf

# 关闭cluster完全覆盖
cluster-require-full-coverage no

# 配置节点超时时间
cluster-node-timeout 15000
```

文件地址：[cluster.windows7001.conf]()

```
# 端口
port 7001

# 目录地址，需要在redis软件目录下，新建7001文件夹
dir ./7001/

# 开启cluster模式
cluster-enabled yes

# 指定配置文件
cluster-config-file nodes-7001.conf

# 关闭cluster完全覆盖
cluster-require-full-coverage no

# 配置节点超时时间
cluster-node-timeout 15000
```

文件地址：[cluster.windows7002.conf]()

```
# 端口
port 7002

# 目录地址，需要在redis软件目录下，新建7002文件夹
dir ./7002/

# 开启cluster模式
cluster-enabled yes

# 指定配置文件
cluster-config-file nodes-7002.conf

# 关闭cluster完全覆盖
cluster-require-full-coverage no

# 配置节点超时时间
cluster-node-timeout 15000
```

###  启动服务

启动7000 、7001和 7002

```
.\redis-server E:\ZHQ\project\0626\geek-study2\geek-study\job\week12\cluster.windows7000.conf 
.\redis-server E:\ZHQ\project\0626\geek-study2\geek-study\job\week12\cluster.windows7001.conf
.\redis-server E:\ZHQ\project\0626\geek-study2\geek-study\job\week12\cluster.windows7002.conf 
```

### 配置服务

1. 进入7000，查看一下当前cluster状态

```shell
cluster nodes# 查看集群节点信息，只有当前节点的信息，且显示为主节点
# 71ed31981e1ac0bb05a630f4179b3b7f9255b28b :7000@17000 myself,master - 0 0 0 connected
# 只有当前7000这个节点

cluster info 
/**输出如下
cluster_state:fail   # 集群为失败状态
cluster_slots_assigned:0
cluster_slots_ok:0	
cluster_slots_pfail:0
cluster_slots_fail:0
cluster_known_nodes:1	# 只有一个节点
cluster_size:0
cluster_current_epoch:0
cluster_my_epoch:0
cluster_stats_messages_sent:0
cluster_stats_messages_received:0*/

exit 
```

2. 使用7000向7001和7002发送meet ，用于将启用了群集支持的不同 Redis 节点连接到工作群集

```
redis-cli -p 7000 cluster meet 127.0.0.1 7001
redis-cli -p 7000 cluster meet 127.0.0.1 7002

# 查看7000 的cluster 节点状态
redis-cli -p 7000 cluster nodes
/**
1cb5de50d5ba2deacb93fae254d4cf474e0795e0 127.0.0.1:7002@17002 master - 0 1631439350118 2 connected
c194185cb32f960bd2660f3e4317cba54b9bab8a 127.0.0.1:7001@17001 master - 0 1631439351218 0 connected
71ed31981e1ac0bb05a630f4179b3b7f9255b28b 127.0.0.1:7000@17000 myself,master - 0 1631439348000 1 connected**/

# 查看7001 的cluster 节点状态
redis-cli -p 7001 cluster nodes
/**
1cb5de50d5ba2deacb93fae254d4cf474e0795e0 127.0.0.1:7002@17002 master - 0 1631439364869 2 connected
c194185cb32f960bd2660f3e4317cba54b9bab8a 127.0.0.1:7001@17001 myself,master - 0 1631439362000 0 connected
71ed31981e1ac0bb05a630f4179b3b7f9255b28b 127.0.0.1:7000@17000 master - 0 1631439363798 1 connected**/


# 查看7002 的cluster 节点状态
redis-cli -p 7002 cluster nodes
/**
71ed31981e1ac0bb05a630f4179b3b7f9255b28b 127.0.0.1:7000@17000 master - 0 1631439372382 1 connected
c194185cb32f960bd2660f3e4317cba54b9bab8a 127.0.0.1:7001@17001 master - 0 1631439373487 0 connected
1cb5de50d5ba2deacb93fae254d4cf474e0795e0 127.0.0.1:7002@17002 myself,master - 0 1631439372000 2 connected**/


# 查看7001 的cluster 集群状态
redis-cli -p 7000 cluster info
/**
cluster_state:fail
cluster_slots_assigned:0
cluster_slots_ok:0
cluster_slots_pfail:0
cluster_slots_fail:0
cluster_known_nodes:3
cluster_size:0
cluster_current_epoch:2
cluster_my_epoch:1
cluster_stats_messages_ping_sent:2197
cluster_stats_messages_pong_sent:2358
cluster_stats_messages_meet_sent:2
cluster_stats_messages_sent:4557
cluster_stats_messages_ping_received:2358
cluster_stats_messages_pong_received:2199
cluster_stats_messages_received:4557
*/
# 现在集群状态还是有问题的，但是可以看到已经有3个节点了。
```

3. 编写脚本并将脚本放于redis根目录下，用于分配slot槽位。[文件地址]()

```bash
@echo off
set /a port = "%3"
echo port %port%
echo start: '%1' ,end: '%2', port: '%port'
for /l %%I in (%1,1,%2) do (
    echo slot: '%%I'
   .\redis-cli -p %port% cluster addslots %%I
)
pause
```

4. 分别执行以下代码，用于分配slot到三个redis服务上

```shell
# 将0-5461分配到7000端口的redis服务上
.\cluster-addslot.bat 0 5461 7000

# 将5462-10922分配到7001端口的redis服务上
.\cluster-addslot.bat 5462 10922 7001

# 将10933-16383分配到7002端口的redis服务上
.\cluster-addslot.bat 10923 16383 7002
```

5. 查看配置状态

```shell
# 查看7000服务的状态
redis-cli -p 7000 cluster info
/**
cluster_state:ok
cluster_slots_assigned:1970
cluster_slots_ok:1970
cluster_slots_pfail:0
cluster_slots_fail:0
cluster_known_nodes:3
cluster_size:1
cluster_current_epoch:2
cluster_my_epoch:1
cluster_stats_messages_ping_sent:4588
cluster_stats_messages_pong_sent:4885
cluster_stats_messages_meet_sent:2
cluster_stats_messages_sent:9475
cluster_stats_messages_ping_received:4885
cluster_stats_messages_pong_received:4590
cluster_stats_messages_received:9475
*/
# 这里可以看到cluster状态已经是正常了，有1970个slot已经分配好了，且正常。

# 查看集群的node状态
redis-cli -p 7000 cluster nodes
/**
1) 1) (integer) 0
   2) (integer) 2108
   3) 1) "127.0.0.1"
      2) (integer) 7000
      3) "71ed31981e1ac0bb05a630f4179b3b7f9255b28b"
*/
```

6. 尝试写入数据

```shell
redis-cli -p 7000 set hello 123
# 输出成功

.\redis-cli -p 7000 set testhello 2..
# 输出(error) CLUSTERDOWN Hash slot not served
# 因为是在slot分配前执行的操作，说明hash后的结果的slot暂未分配，并没有提供服务。
```



# 作业6

## Topic

测试代码：[文件地址]()

```java
package top.zsmile.activemq.demo;

import org.apache.activemq.ActiveMQConnectionFactory;
import org.apache.activemq.command.ActiveMQQueue;
import org.apache.activemq.command.ActiveMQTopic;

import javax.jms.*;
import java.util.concurrent.atomic.AtomicInteger;

public class ActiveTopicDemo {
    public static void main(String[] args) {
        Destination activeMQQueue = new ActiveMQTopic("testTopic");

        testQueue(activeMQQueue);
    }

    public static void testQueue(Destination destination) {
        try {
            ActiveMQConnectionFactory activeMQConnectionFactory = new ActiveMQConnectionFactory("tcp://127.0.0.1:61616");

            Connection connection = activeMQConnectionFactory.createConnection();
            connection.start();
            Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);

            MessageConsumer consumer = session.createConsumer(destination);
            AtomicInteger atomicInteger = new AtomicInteger(0);
            MessageListener messageListener = new MessageListener() {
                @Override
                public void onMessage(Message message) {
                    System.out.println("consumer1：" + atomicInteger.incrementAndGet() + "==> receive " + message);
                }
            };
            consumer.setMessageListener(messageListener);


            MessageConsumer consumer2 = session.createConsumer(destination);
            AtomicInteger atomicInteger2 = new AtomicInteger(0);
            MessageListener messageListener2 = new MessageListener() {
                @Override
                public void onMessage(Message message) {
                    System.out.println("consumer2：" + atomicInteger2.incrementAndGet() + "==> receive " + message);
                }
            };
            consumer2.setMessageListener(messageListener2);

            MessageProducer producer = session.createProducer(destination);
            int index = 0;
            while (index++ < 100) {
                TextMessage message = session.createTextMessage(index + " message.");
                producer.send(message);
            }

            Thread.sleep(20000);

            session.close();
            connection.close();

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```



## Queue

测试代码：[文件地址]()

```java
package top.zsmile.activemq.demo;

import org.apache.activemq.ActiveMQConnection;
import org.apache.activemq.ActiveMQConnectionFactory;
import org.apache.activemq.command.ActiveMQQueue;

import javax.jms.*;
import java.util.concurrent.atomic.AtomicInteger;

public class ActiveQueueDemo {
    public static void main(String[] args) {
        Destination activeMQQueue = new ActiveMQQueue("testQueue");

        testQueue(activeMQQueue);
    }

    public static void testQueue(Destination destination) {
        try {
            ActiveMQConnectionFactory activeMQConnectionFactory = new ActiveMQConnectionFactory("tcp://127.0.0.1:61616");

            Connection connection = activeMQConnectionFactory.createConnection();
            connection.start();
            Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);

            MessageConsumer consumer = session.createConsumer(destination);
            AtomicInteger atomicInteger = new AtomicInteger(0);
            MessageListener messageListener = new MessageListener() {
                @Override
                public void onMessage(Message message) {
                    System.out.println(atomicInteger.incrementAndGet() + "==> receive " + message);
                }
            };
            consumer.setMessageListener(messageListener);

            MessageProducer producer = session.createProducer(destination);
            int index = 0;
            while (index++ < 100) {
                TextMessage message = session.createTextMessage(index + " message.");
                producer.send(message);
            }

            Thread.sleep(20000);

            session.close();
            connection.close();

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

```



# 作业9

测试代码：[文件地址]()

```java
package top.zsmile.activemq.demo;

import org.apache.activemq.broker.BrokerService;
import org.apache.activemq.broker.TransportConnection;
import org.apache.activemq.broker.TransportConnector;
import org.apache.activemq.store.memory.MemoryPersistenceAdapter;

import java.net.URI;

public class ActiveBrokerDemo {

    public static void main(String[] args) throws Exception {
        BrokerService brokerService = new BrokerService();
        brokerService.setBrokerName("zsmile");
        brokerService.setUseJmx(true);
        TransportConnector transportConnector = new TransportConnector();
        transportConnector.setUri(new URI("tcp://127.0.0.1:61616"));
        brokerService.addConnector(transportConnector);
        brokerService.start();

        System.out.println("activemq broker start...");
        System.in.read();
    }
}
```

启动后使用作业的代码进行测试。可以看到broker输出日志

```java

21:59:55.962 [ActiveMQ BrokerService[zsmile] Task-4] DEBUG org.apache.activemq.broker.region.Queue - queue://testQueue expiring messages ..
21:59:55.962 [ActiveMQ BrokerService[zsmile] Task-4] DEBUG org.apache.activemq.broker.region.Queue - queue://testQueue, subscriptions=0, memory=0%, size=0, pending=0 toPageIn: 0, force:true, Inflight: 0, pagedInMessages.size 0, pagedInPendingDispatch.size 0, enqueueCount: 100, dequeueCount: 100, memUsage:0, maxPageSize:400
21:59:55.962 [ActiveMQ BrokerService[zsmile] Task-4] DEBUG org.apache.activemq.broker.region.Queue - queue://testQueue expiring messages done.
21:59:55.962 [ActiveMQ BrokerService[zsmile] Task-5] DEBUG org.apache.activemq.broker.region.Queue - queue://testQueue, subscriptions=0, memory=0%, size=0, pending=0 toPageIn: 0, force:false, Inflight: 0, pagedInMessages.size 0, pagedInPendingDispatch.size 0, enqueueCount: 100, dequeueCount: 100, memUsage:0, maxPageSize:200
```



